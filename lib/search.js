// Generated by LiveScript 1.4.0
(function(){
  var Charm, vw, ttys, migemo, e, bytesToString, DOWN, UP, BACKSPACE, CTRLC, CTRLD, ENTER, search, cleanupScreen, drawScreen, getHits, queryHits, readStdinAsLinesThen, noEmpty, searchFromStdin, out$ = typeof exports != 'undefined' && exports || this;
  Charm = require('charm');
  vw = require('visualwidth');
  ttys = require('ttys');
  migemo = null;
  try {
    migemo = require('node-migemo');
  } catch (e$) {
    e = e$;
  }
  bytesToString = function(it){
    switch (it.toString()) {
    case "\n":
    case "\r":
      return "\n";
    default:
      return [].join.call(it, '.');
    }
  };
  DOWN = '27.91.66';
  UP = '27.91.65';
  BACKSPACE = '127';
  CTRLC = '3';
  CTRLD = '4';
  ENTER = "\n";
  out$.search = search = function(items, cb){
    var charm, state;
    charm = Charm();
    charm.pipe(ttys.stdout);
    charm.reset();
    charm.cursor(false);
    ttys.stdin.setRawMode(true);
    state = {
      needle: '',
      height: 0,
      matches: []
    };
    ttys.stdin.on('data', function(chunk){
      var rows, cols, that;
      if (state.height < 0) {
        state.height = 0;
      }
      if (vw.width(chunk.toString()) === 0) {
        return;
      }
      rows = ttys.stdout.rows;
      cols = ttys.stdout.columns;
      switch (that = bytesToString(chunk)) {
      case UP:
        state.height = Math.max(0, state.height - 1);
        break;
      case DOWN:
        state.height = Math.min(rows, state.matches.length - 1, state.height + 1);
        break;
      case CTRLC:
      case CTRLD:
        cleanupScreen(charm);
        process.exit();
        break;
      case ENTER:
        cleanupScreen(charm);
        if (typeof cb == 'function') {
          cb(state.matches[state.height]);
        }
        break;
      case BACKSPACE:
        state.height = 0;
        if (state.needle.length > 0) {
          state.needle = state.needle.substr(0, state.needle.length - 1);
        }
        break;
      default:
        if (0 !== that.indexOf("27.91.")) {
          state.needle = state.needle + chunk;
          state.height = 0;
        }
      }
      getHits(state, items, rows);
      return drawScreen(charm, rows, cols, state.needle, state.height, state.matches);
    });
    ttys.stdin.emit('data', [27, 91, 66]);
    return ttys.stdin.emit('data', [27, 91, 65]);
  };
  cleanupScreen = function(charm){
    ttys.stdin.setRawMode(false);
    ttys.stdin.end();
    charm.erase('screen');
    charm.cursor(true);
    charm.display('reset');
    charm.position(1, 1);
    return charm.end();
  };
  drawScreen = function(charm, rows, columns, needle, selRow, matches){
    var i$, to$, row, padLength;
    charm.erase('screen');
    charm.position(1, 1);
    charm.write("query: " + needle);
    for (i$ = 0, to$ = rows - 1; i$ < to$; ++i$) {
      row = i$;
      if (row >= matches.length) {
        return;
      }
      charm.position(1, row + 2);
      if (row === selRow) {
        charm.display('reverse');
      }
      padLength = Math.max(0, columns - vw.width(matches[row]));
      charm.write(matches[row] + repeatString$(' ', padLength));
      charm.display('reset');
    }
  };
  getHits = function(state, items, rows){
    var matches, i$, len$, item;
    matches = [];
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      item = items[i$];
      if (queryHits(state.needle, item)) {
        matches.push(item);
      }
      if (matches.length > rows) {
        break;
      }
    }
    return state.matches = matches;
  };
  queryHits = function(needle, haystack){
    var regex, option;
    if (!needle || needle.length === 0) {
      return true;
    }
    regex = null;
    if (migemo) {
      regex = migemo.toRegex(needle);
    } else {
      option = /[A-Z]/.test(needle) ? "" : 'i';
      regex = new RegExp(needle, option);
    }
    return regex.test(haystack);
  };
  readStdinAsLinesThen = function(func){
    var buf;
    buf = '';
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(it){
      return buf += it;
    });
    return process.stdin.on('end', function(){
      return func(noEmpty(
      buf.split("\n")));
    });
  };
  noEmpty = function(it){
    return it.filter(function(it){
      return !(it === null || it === '');
    });
  };
  out$.searchFromStdin = searchFromStdin = function(){
    return readStdinAsLinesThen(function(it){
      return search(it, function(it){
        return console.log(it);
      });
    });
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);
