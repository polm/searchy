// Generated by LiveScript 1.4.0
(function(){
  var Charm, vw, ttys, migemo, e, bytesToString, DOWN, UP, BACKSPACE, CTRLC, CTRLD, CTRLK, CTRLJ, CTRLN, CTRLP, ENTER, search, searchUsingDefault, searchCore, cleanupScreen, drawScreen, drawRow, getHits, queryHits, SearchyMatch, readStdinAsLinesThen, noEmpty, searchFromStdin, out$ = typeof exports != 'undefined' && exports || this;
  Charm = require('charm');
  vw = require('visualwidth');
  ttys = require('ttys');
  migemo = null;
  try {
    migemo = require('migemo');
  } catch (e$) {
    e = e$;
  }
  bytesToString = function(it){
    return [].join.call(it, '.');
  };
  DOWN = '27.91.66';
  UP = '27.91.65';
  BACKSPACE = '127';
  CTRLC = '3';
  CTRLD = '4';
  CTRLK = '11';
  CTRLJ = '10';
  CTRLN = '14';
  CTRLP = '16';
  ENTER = '13';
  out$.search = search = function(items, cb, matcher){
    return searchCore(items, cb, null, matcher);
  };
  out$.searchUsingDefault = searchUsingDefault = function(items, cb, defaultCb, matcher){
    return searchCore(items, cb, defaultCb || cb, matcher);
  };
  searchCore = function(items, cb, defaultCb, matcher){
    var charm, state;
    charm = Charm();
    charm.pipe(ttys.stdout);
    charm.reset();
    charm.cursor(true);
    charm.foreground('white');
    ttys.stdin.setRawMode(true);
    state = {
      needle: '',
      height: 0,
      matches: []
    };
    ttys.stdin.on('data', function(chunk){
      var rows, cols, that, oldHeight, countString;
      if (state.height < 0) {
        state.height = 0;
      }
      if (vw.width(chunk.toString()) === 0) {
        return;
      }
      rows = ttys.stdout.rows;
      cols = ttys.stdout.columns;
      charm.cursor(false);
      switch (that = bytesToString(chunk)) {
      case UP:
      case CTRLP:
      case CTRLK:
        oldHeight = state.height;
        state.height = Math.max(0, state.height - 1);
        drawRow(charm, rows, cols, state.needle, state.height, state.matches, oldHeight);
        drawRow(charm, rows, cols, state.needle, state.height, state.matches, state.height);
        break;
      case DOWN:
      case CTRLN:
      case CTRLJ:
        oldHeight = state.height;
        state.height = Math.min(rows, state.matches.length - 1, state.height + 1);
        drawRow(charm, rows, cols, state.needle, state.height, state.matches, oldHeight);
        drawRow(charm, rows, cols, state.needle, state.height, state.matches, state.height);
        break;
      case CTRLC:
      case CTRLD:
        cleanupScreen(charm);
        process.exit();
        break;
      case ENTER:
        cleanupScreen(charm);
        if (state.matches.length > 0) {
          if (typeof cb == 'function') {
            cb(state.matches[state.height]);
          }
        } else {
          if (typeof defaultCb == 'function') {
            defaultCb(state.needle);
          }
        }
        break;
      case BACKSPACE:
        state.height = 0;
        if (state.needle.length > 0) {
          state.needle = state.needle.substr(0, state.needle.length - 1);
        }
        getHits(state, items, rows, matcher);
        drawScreen(charm, rows, cols, state.needle, state.height, state.matches);
        break;
      default:
        if (0 !== that.indexOf("27.91.")) {
          state.needle = state.needle + chunk;
          state.height = 0;
        }
        getHits(state, items, rows, matcher);
        drawScreen(charm, rows, cols, state.needle, state.height, state.matches);
      }
      countString = "(" + state.matches.length + "/" + items.length + ")";
      charm.position(cols - countString.length, 1);
      charm.write(countString);
      charm.cursor(true);
      return charm.position(("query: " + state.needle).length + 1, 1);
    });
    return ttys.stdin.emit('data', [127]);
  };
  cleanupScreen = function(charm){
    charm.display('reset');
    charm.erase('up');
    charm.erase('down');
    charm.position(1, 1);
    charm.cursor(true);
    charm.end();
    ttys.stdin.setRawMode(false);
    return ttys.stdin.end();
  };
  drawScreen = function(charm, rows, columns, needle, selRow, matches, oldRow){
    var i$, to$, row, results$ = [];
    oldRow == null && (oldRow = -1);
    charm.display('reset');
    charm.erase('screen');
    charm.position(1, 1);
    charm.write("query: " + needle);
    for (i$ = 0, to$ = rows - 1; i$ < to$; ++i$) {
      row = i$;
      results$.push(drawRow(charm, rows, columns, needle, selRow, matches, row));
    }
    return results$;
  };
  drawRow = function(charm, rows, columns, needle, selRow, matches, row){
    var txt, padLength, hit;
    charm.display('reset');
    if (row < 0) {
      return;
    }
    charm.position(1, row + 2);
    if (row >= matches.length) {
      charm.erase('line');
      return;
    }
    if (row === selRow) {
      charm.display('reverse');
    }
    txt = matches[row].toString();
    padLength = Math.max(0, columns - vw.width(txt));
    if (!matches[row].hit) {
      return charm.write(vw.truncate(txt + repeatString$(' ', padLength), columns, ''));
    } else {
      hit = matches[row].hit;
      if (vw.width(txt) > columns) {
        txt = vw.truncate(txt, columns, '');
        if (columns < vw.width(txt.substr(0, hit.index))) {
          hit.index = 0;
          hit.length = 0;
        }
        if (txt.length < hit.index + hit.length) {
          hit.length = txt.length - hit.index;
        }
      }
      charm.write(txt.substr(0, hit.index));
      charm.foreground('yellow');
      charm.write(txt.substr(hit.index, hit[0].length));
      charm.display('reset');
      if (row === selRow) {
        charm.display('reverse');
      }
      charm.write(txt.substr(hit.index + hit[0].length));
      return charm.write(repeatString$(' ', padLength));
    }
  };
  getHits = function(state, items, rows, matcher){
    var matches, i$, len$, item, hit;
    matches = [];
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      item = items[i$];
      hit = queryHits(state.needle, item, matcher);
      if (hit) {
        matches.push(hit);
      }
      if (matches.length > rows) {
        break;
      }
    }
    return state.matches = matches;
  };
  queryHits = function(needle, haystack, matcher){
    var regex, option;
    if (!needle || needle.length === 0) {
      return haystack;
    }
    regex = null;
    if (matcher) {
      if (matcher(needle, haystack)) {
        return haystack;
      }
    } else {
      if (migemo) {
        regex = migemo.toRegex(needle);
      } else {
        option = /[A-Z]/.test(needle) ? "" : 'i';
        regex = new RegExp(needle, option);
      }
      if (regex.test(haystack)) {
        return SearchyMatch(haystack, haystack.match(regex));
      }
    }
  };
  SearchyMatch = (function(){
    SearchyMatch.displayName = 'SearchyMatch';
    var prototype = SearchyMatch.prototype, constructor = SearchyMatch;
    function SearchyMatch(text, hit){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.text = text;
      this$.hit = hit;
      this$.toString = bind$(this$, 'toString', prototype);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.toString = function(){
      return this.text;
    };
    return SearchyMatch;
  }());
  readStdinAsLinesThen = function(func){
    var buf;
    buf = '';
    process.stdin.setEncoding('utf-8');
    process.stdin.on('data', function(it){
      return buf += it;
    });
    return process.stdin.on('end', function(){
      return func(noEmpty(
      buf.split("\n")));
    });
  };
  noEmpty = function(it){
    return it.filter(function(it){
      return !(it === null || it === '');
    });
  };
  out$.searchFromStdin = searchFromStdin = function(){
    return readStdinAsLinesThen(function(it){
      return search(it, function(it){
        return console.log(it);
      });
    });
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
